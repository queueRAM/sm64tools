#include <inttypes.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

#include <zlib.h>

#include "config.h"
#include "libblast.h"
#include "libmio0.h"
#include "libsfx.h"
#include "mipsdisasm.h"
#include "n64graphics.h"
#include "strutils.h"
#include "utils.h"

#define N64SPLIT_VERSION "0.4a"

#define GLOBALS_FILE "globals.inc"
#define MACROS_FILE "macros.inc"

typedef struct _arg_config
{
   char input_file[FILENAME_MAX];
   char config_file[FILENAME_MAX];
   char output_dir[FILENAME_MAX];
   float model_scale;
   bool raw_texture; // TODO: this should be the default path once n64graphics is updated
   bool large_texture;
   bool large_texture_depth;
   bool keep_going;
   bool merge_pseudo;
} arg_config;

typedef enum {
   N64_ROM_INVALID,
   N64_ROM_Z64,
   N64_ROM_V64,
} n64_rom_format;

// default configuration
static const arg_config default_args = 
{
   .input_file = "",
   .config_file = "",
   .output_dir = "",
   .model_scale = 1024.0f,
   .raw_texture = false,
   .large_texture = false,
   .large_texture_depth = 16,
   .keep_going = false,
   .merge_pseudo = false,
};

// static files
#include "n64split.makefile.h"
#include "n64split.collision.mtl.h"

const char asm_header[] = 
   "# %s disassembly and split file\n"
   "# generated by n64split v%s - N64 ROM splitter\n"
   "\n"
   "# assembler directives\n"
   ".set noat      # allow manual use of $at\n"
   ".set noreorder # don't insert nops after branches\n"
   "\n"
   ".include \"" GLOBALS_FILE "\"\n"
   "\n";

static void print_spaces(FILE *fp, int count)
{
   int i;
   for (i = 0; i < count; i++) {
      fputc(' ', fp);
   }
}

static n64_rom_format n64_rom_type(unsigned char *buf, unsigned int length)
{
   const unsigned char bs[] = {0x37, 0x80, 0x40, 0x12}; // byte-swapped
   const unsigned char be[] = {0x80, 0x37, 0x12, 0x40}; // big-endian
   if (length >= (8 * MB)) {
      if (!memcmp(buf, bs, sizeof(bs))) {
         return N64_ROM_V64;
      }
      if (!memcmp(buf, be, sizeof(be))) {
         return N64_ROM_Z64;
      }
   }
   return N64_ROM_INVALID;
}

static void gzip_decode_file(char *gzfilename, int offset, char *binfilename)
{
#define CHUNK 0x4000
   FILE *file;
   FILE *fout;
   z_stream strm = {0};
   unsigned char in[CHUNK];
   unsigned char out[CHUNK];

   // TODO: add some error checking
   strm.zalloc = Z_NULL;
   strm.zfree = Z_NULL;
   strm.opaque = Z_NULL;
   strm.avail_in = 0;
   inflateInit2(&strm, 16+MAX_WBITS);

   file = fopen(gzfilename, "rb");
   fout = fopen(binfilename, "wb");
   fseek(file, offset, SEEK_SET);
   while (1) {
      int bytes_read;
      bytes_read = fread(in, sizeof(char), sizeof(in), file);
      strm.avail_in = bytes_read;
      strm.next_in = in;
      do {
         strm.avail_out = CHUNK;
         strm.next_out = out;
         inflate(&strm, Z_NO_FLUSH);
         fwrite(out, sizeof(char), CHUNK - strm.avail_out, fout);
      } while (strm.avail_out == 0);
      if (feof(file)) {
         inflateEnd(&strm);
         break;
      }
   }
   fclose(file);
   fclose(fout);
}

static int config_section_lookup(rom_config *config, unsigned int addr, char *label, int is_end)
{
   int i;
   // check for ROM offsets
   switch (is_end) {
      case 0:
         for (i = 0; i < config->section_count; i++) {
            // TODO: hack until mario_animation gets moved or AT() is used
            if (config->sections[i].start == addr && addr != 0x4EC000) {
               if (config->sections[i].label[0] != '\0') {
                  sprintf(label, "%s", config->sections[i].label);
               } else {
                  sprintf(label, "%s_%06X", config_section2str(config->sections[i].type), addr);
               }
               INFO("Found 0 %06X: %s\n", addr, label);
               return 0;
            }
         }
         break;
      case 1:
         for (i = 0; i < config->section_count; i++) {
            if (config->sections[i].end == addr) {
               if (config->sections[i].label[0] != '\0') {
                  sprintf(label, "%s_end", config->sections[i].label);
               } else {
                  sprintf(label, "%s_%06X", config_section2str(config->sections[i].type), addr);
               }
               INFO("Found 1 %06X: %s\n", addr, label);
               return 0;
            }
         }
         break;
      default:
         break;
   }
   sprintf(label, "0x%X", addr);
   return -1;
}

static void write_behavior(FILE *out, unsigned char *data, rom_config *config, int s, disasm_state *state)
{
   char label[128];
   unsigned int a, i;
   unsigned int len;
   unsigned int val;
   int beh_i;
   split_section *sec;
   split_section *beh;
   sec = &config->sections[s];
   beh = sec->children;
   a = sec->start;
   beh_i = 0;
   while (a < sec->end) {
      if (beh_i < sec->child_count) {
         unsigned int offset = a - sec->start;
         if (offset == beh[beh_i].start) {
            fprintf(out, "%s: # %04X\n", beh[beh_i].label, beh[beh_i].start);
            beh_i++;
         } else if (offset > beh[beh_i].start) {
            ERROR("Warning: skipped behavior %04X \"%s\"\n", beh[beh_i].start, beh[beh_i].label);
            beh_i++;
         }
      }
      switch (data[a]) {
         case 0x02:
         case 0x04:
         case 0x0C:
         case 0x13:
         case 0x14:
         case 0x15:
         case 0x16:
         case 0x17:
         case 0x23:
         case 0x27:
         case 0x2A:
         case 0x2E:
         case 0x2F:
         case 0x31:
         case 0x33:
         case 0x36:
         case 0x37:
            len = 8;
            break;
         case 0x1C:
         case 0x29:
         case 0x2B:
         case 0x2C:
            len = 12;
            break;
         case 0x30:
            len = 20;
            break;
         default:
            len = 4;
            break;
      }
      val = read_u32_be(&data[a]);
      fprintf(out, ".word 0x%08X", val);
      switch(data[a]) {
         case 0x0C: // behavior 0x0C is a function pointer
            val = read_u32_be(&data[a+4]);
            disasm_label_lookup(state, val, label);
            fprintf(out, ", %s\n", label);
            break;
         case 0x02: // jump to another behavior
         case 0x04: // jump to segmented address
         case 0x1C: // sub-objects
         case 0x29: // sub-objects
         case 0x2C: // sub-objects
            for (i = 4; i < len-4; i += 4) {
               val = read_u32_be(&data[a+i]);
               fprintf(out, ", 0x%08X", val);
            }
            val = read_u32_be(&data[a+len-4]);
            disasm_label_lookup(state, val, label);
            fprintf(out, ", %s\n", label);
            break;
         default:
            for (i = 4; i < len; i += 4) {
               val = read_u32_be(&data[a+i]);
               fprintf(out, ", 0x%08X", val);
            }
            fprintf(out, "\n");
            break;
      }
      a += len;
   }
}

typedef struct
{
   int length;
   const char *macro;
} geo_command;

static geo_command geo_table[] =
{
   /* 0x00 */ {0x08, "geo_branch_and_link"},
   /* 0x01 */ {0x04, "geo_end"},
   /* 0x02 */ {0x08, "geo_branch"},
   /* 0x03 */ {0x04, "geo_return"},
   /* 0x04 */ {0x04, "geo_open_node"},
   /* 0x05 */ {0x04, "geo_close_node"},
   /* 0x06 */ {0x04, "geo_todo_06"},
   /* 0x07 */ {0x04, "geo_update_node_flags"},
   /* 0x08 */ {0x0C, "geo_node_screen_area"},
   /* 0x09 */ {0x04, "geo_todo_09"},
   /* 0x0A */ {0x08, "geo_camera_frustum"}, // 8-12 variable
   /* 0x0B */ {0x04, "geo_node_start"},
   /* 0x0C */ {0x04, "geo_zbuffer"},
   /* 0x0D */ {0x08, "geo_render_range"},
   /* 0x0E */ {0x08, "geo_switch_case"},
   /* 0x0F */ {0x14, "geo_todo_0F"},
   /* 0x10 */ {0x10, "geo_translate_rotate"}, // variable
   /* 0x11 */ {0x08, "geo_todo_11"}, // variable
   /* 0x12 */ {0x08, "geo_todo_12"}, // variable
   /* 0x13 */ {0x0C, "geo_dl_translated"},
   /* 0x14 */ {0x08, "geo_billboard"},
   /* 0x15 */ {0x08, "geo_display_list"},
   /* 0x16 */ {0x08, "geo_shadow"},
   /* 0x17 */ {0x04, "geo_todo_17"},
   /* 0x18 */ {0x08, "geo_asm"},
   /* 0x19 */ {0x08, "geo_background"},
   /* 0x1A */ {0x08, "geo_nop_1A"},
   /* 0x1B */ {0x04, "geo_todo_1B"},
   /* 0x1C */ {0x0C, "geo_todo_1C"},
   /* 0x1D */ {0x08, "geo_scale"}, // variable
   /* 0x1E */ {0x08, "geo_nop_1E"},
   /* 0x1F */ {0x10, "geo_nop_1F"},
   /* 0x20 */ {0x04, "geo_start_distance"},
};

static void write_geolayout(FILE *out, unsigned char *data, unsigned int start, unsigned int end, disasm_state *state)
{
   const int INDENT_AMOUNT = 3;
   const int INDENT_START = INDENT_AMOUNT;
   char label[128];
   unsigned int a = start;
   unsigned int tmp;
   int indent;
   int cmd_len;
   int print_label = 1;
   indent = INDENT_START;
   fprintf(out, ".include \"macros.inc\"\n"
                ".include \"geo_commands.inc\"\n\n"
                ".section .geo, \"a\"\n\n");
   while (a < end) {
      unsigned cmd = data[a];
      if (print_label) {
         fprintf(out, "glabel geo_layout_X_%06X # %04X\n", a, a);
         print_label = 0;
      }
      if ((cmd == 0x01 || cmd == 0x05) && indent > INDENT_AMOUNT) {
         indent -= INDENT_AMOUNT;
      }
      print_spaces(out, indent);
      if (cmd < DIM(geo_table)) {
         if (cmd != 0x10) { // special case 0x10 since multiple pseudo
            fprintf(out, "%s", geo_table[cmd].macro);
         }
      } else {
         ERROR("Unknown geo layout command: 0x%02X\n", cmd);
      }
      cmd_len = geo_table[cmd].length;
      switch (cmd) {
         case 0x00: // 00 00 00 00 [SS SS SS SS]: branch and store
            tmp = read_u32_be(&data[a+4]);
            fprintf(out, " geo_layout_%08X # 0x%08X", tmp, tmp);
            break;
         case 0x01: // 01 00 00 00: terminate
         case 0x03: // 03 00 00 00: return from branch
            // no params
            fprintf(out, "\n");
            indent = INDENT_START;
            print_label = 1;
            break;
         case 0x04: // 04 00 00 00: open node
         case 0x05: // 05 00 00 00: close node
         case 0x0B: // 05 00 00 00: start geo layout
         case 0x17: // 17 00 00 00: set up object rendering
         case 0x1A: // 1A 00 00 00 00 00 00 00: no op
         case 0x1E: // 1E 00 00 00 00 00 00 00: no op
         case 0x1F: // 1E 00 00 00 00 00 00 00 00 00 00 00: no op
            // no params
            break;
         case 0x02: // 02 [AA] 00 00 [SS SS SS SS]
            tmp = read_u32_be(&data[a+4]);
            fprintf(out, " %d, geo_layout_%08X # 0x%08X", data[a+1], tmp, tmp);
            break;
         case 0x08: // 08 00 00 [AA] [XX XX] [YY YY] [WW WW] [HH HH]
            fprintf(out, " %d, %d, %d, %d, %d", data[a+3],
                  read_s16_be(&data[a+4]), read_s16_be(&data[a+6]),
                  read_s16_be(&data[a+8]), read_s16_be(&data[a+10]));
            break;
         case 0x09: // 09 00 00 [AA]
            fprintf(out, " %d", data[a+3]);
            break;
         case 0x0A: // 0A [AA] [BB BB] [NN NN] [FF FF] {EE EE EE EE}: set camera frustum
            fprintf(out, " %d, %d, %d", read_s16_be(&data[a+2]), read_s16_be(&data[a+4]), read_s16_be(&data[a+6]));
            if (data[a+1] > 0) {
               cmd_len += 4;
               disasm_label_lookup(state, read_u32_be(&data[a+8]), label);
               fprintf(out, ", %s", label);
            }
            break;
         case 0x0C: // 0C [AA] 00 00: enable/disable Z-buffer
            fprintf(out, " %d", data[a+1]);
            break;
         case 0x0D: // 0D 00 00 00 [AA AA] [BB BB]: set render range
            fprintf(out, " %d, %d", read_s16_be(&data[a+4]), read_s16_be(&data[a+6]));
            break;
         case 0x0E: // 0E 00 [NN NN] [AA AA AA AA]: switch/case
            fprintf(out, " %d, geo_switch_case_%08X", read_s16_be(&data[a+2]), read_u32_be(&data[a+4]));
            break;
         case 0x0F: // 0F 00 [TT TT] [XX XX] [YY YY] [ZZ ZZ] [UU UU] [VV VV] [WW WW] [AA AA AA AA]
            fprintf(out, " %d, %d, %d, %d, %d, %d, %d", read_s16_be(&data[a+2]),
                  read_s16_be(&data[a+4]), read_s16_be(&data[a+6]), read_s16_be(&data[a+8]),
                  read_s16_be(&data[a+10]), read_s16_be(&data[a+12]), read_s16_be(&data[a+14]));
            disasm_label_lookup(state, read_u32_be(&data[a+0x10]), label);
            fprintf(out, ", %s", label);
            break;
         case 0x10: // 10 [AA] [BB BB] [XX XX] [YY YY] [ZZ ZZ] [RX RX] [RY RY] [RZ RZ] {SS SS SS SS}: translate & rotate
         {
            unsigned char params = data[a+1];
            unsigned char field_type = (params & 0x70) >> 4;
            unsigned char layer = params & 0xF;
            switch (field_type) {
               case 0: // 10 [0L] 00 00 [TX TX] [TY TY] [TZ TZ] [RX RX] [RY RY] [RZ RZ] {SS SS SS SS}: translate & rotate
                  fprintf(out, "geo_translate_rotate %d, %d, %d, %d, %d, %d, %d", layer,
                          read_s16_be(&data[a+4]), read_s16_be(&data[a+6]), read_s16_be(&data[a+8]),
                          read_s16_be(&data[a+10]), read_s16_be(&data[a+12]), read_s16_be(&data[a+14]));
                  cmd_len = 16;
                  break;
               case 1: // 10 [1L] [TX TX] [TY TY] [TZ TZ] {SS SS SS SS}: translate
                  fprintf(out, "geo_translate %d, %d, %d, %d", layer,
                          read_s16_be(&data[a+2]), read_s16_be(&data[a+4]), read_s16_be(&data[a+6]));
                  cmd_len = 8;
                  break;
               case 2: // 10 [2L] [RX RX] [RY RY] [RZ RZ] {SS SS SS SS}: rotate
                  fprintf(out, "geo_rotate %d, %d, %d, %d", layer,
                          read_s16_be(&data[a+2]), read_s16_be(&data[a+4]), read_s16_be(&data[a+6]));
                  cmd_len = 8;
                  break;
               case 3: // 10 [3L] [RY RY] {SS SS SS SS}: rotate Y
                  fprintf(out, "geo_rotate_y %d, %d", layer, read_s16_be(&data[a+2]));
                  cmd_len = 4;
                  break;
            }
            if (params & 0x80) {
               tmp = read_u32_be(&data[a+cmd_len]);
               fprintf(out, ", seg%X_dl_%08X", (tmp >> 24) & 0xFF, tmp);
               cmd_len += 4;
            }
            break;
         }
         case 0x11: // 11 [P][L] [XX XX] [YY YY] [ZZ ZZ] {SS SS SS SS}: ? scene graph node, optional DL
         case 0x12: // 12 [P][L] [XX XX] [YY YY] [ZZ ZZ] {SS SS SS SS}: ? scene graph node, optional DL
         case 0x14: // 14 [P][L] [XX XX] [YY YY] [ZZ ZZ] {SS SS SS SS}: billboard model
            fprintf(out, " 0x%02X, %d, %d, %d", data[a+1] & 0xF, read_s16_be(&data[a+2]),
                  read_s16_be(&data[a+4]), read_s16_be(&data[a+6]));
            if (data[a+1] & 0x80) {
               disasm_label_lookup(state, read_u32_be(&data[a+8]), label);
               fprintf(out, ", %s", label);
               cmd_len += 4;
            }
            break;
         case 0x13: // 13 [LL] [XX XX] [YY YY] [ZZ ZZ] [AA AA AA AA]: scene graph node with layer and translation
            fprintf(out, " 0x%02X, %d, %d, %d", data[a+1],
                    read_s16_be(&data[a+2]), read_s16_be(&data[a+4]), read_s16_be(&data[a+6]));
            tmp = read_u32_be(&data[a+8]);
            if (tmp != 0x0) {
               fprintf(out, ", seg%X_dl_%08X", data[a+8], tmp);
            }
            break;
         case 0x15: // 15 [LL] 00 00 [AA AA AA AA]: load display list
            fprintf(out, " 0x%02X, seg%X_dl_%08X", data[a+1], data[a+4], read_u32_be(&data[a+4]));
            break;
         case 0x16: // 16 00 00 [AA] 00 [BB] [CC CC]: start geo layout with shadow
            fprintf(out, " 0x%02X, 0x%02X, %d", data[a+3], data[a+5], read_s16_be(&data[a+6]));
            break;
         case 0x18: // 18 00 [XX XX] [AA AA AA AA]: load polygons from asm
         case 0x19: // 19 00 [TT TT] [AA AA AA AA]: set background/skybox
            disasm_label_lookup(state, read_u32_be(&data[a+4]), label);
            fprintf(out, " %d, %s", read_s16_be(&data[a+2]), label);
            break;
         case 0x1B: // 1B 00 [XX XX]: ??
            fprintf(out, " %d", read_s16_be(&data[a+2]));
            break;
         case 0x1C: // 1C [PP] [XX XX] [YY YY] [ZZ ZZ] [AA AA AA AA]
            disasm_label_lookup(state, read_u32_be(&data[a+8]), label);
            fprintf(out, " 0x%02X, %d, %d, %d, %s", data[a+1], read_s16_be(&data[a+2]),
                    read_s16_be(&data[a+4]), read_s16_be(&data[a+6]), label);
            break;
         case 0x1D: // 1D [P][L] 00 00 [MM MM MM MM] {SS SS SS SS}: scale model
            fprintf(out, " 0x%02X, %d", data[a+1] & 0xF, read_u32_be(&data[a+4]));
            if (data[a+1] & 0x80) {
               disasm_label_lookup(state, read_u32_be(&data[a+8]), label);
               fprintf(out, ", %s", label);
               cmd_len += 4;
            }
            break;
         case 0x20: // 20 00 [AA AA]: start geo layout with rendering area
            fprintf(out, " %d", read_s16_be(&data[a+2]));
            break;
         default:
            ERROR("Unknown geo layout command: 0x%02X\n", cmd);
            break;
      }
      fprintf(out, "\n");
      switch (cmd) {
         case 0x04: // open_node
         case 0x08: // node_screen_area
         //case 0x0B: // node_start
         case 0x16: // geo_shadow
         case 0x20: // start_distance
            indent += INDENT_AMOUNT;
         default:
            break;
      }
      if (cmd == 0x01 || cmd == 0x03) { // end or return
         a += cmd_len;
         cmd_len = 0;
         while (a < end && 0 == read_u32_be(&data[a])) {
             fprintf(out, ".word 0x0\n");
             a += 4;
         }
      }
      a += cmd_len;
   }
}

static void write_level(FILE *out, unsigned char *data, rom_config *config, int s, disasm_state *state)
{
   char start_label[128];
   char end_label[128];
   char dst_label[128];
   split_section *sec;
   unsigned int ptr_start;
   unsigned int ptr_end;
   unsigned int dst;
   unsigned int a;
   int i;
   int beh_i;

   sec = &config->sections[s];

   beh_i = -1;
   // see if there is a behavior section
   for (i = 0; i < config->section_count; i++) {
      if (config->sections[i].type == TYPE_SM64_BEHAVIOR) {
         beh_i = i;
         break;
      }
   }
   a = sec->start;
   while (a < sec->end) {
      // length = 0 ends level script
      if (data[a+1] == 0) {
         break;
      }
      switch (data[a]) {
         case 0x00: // load and jump from ROM into a RAM segment
         case 0x01: // load and jump from ROM into a RAM segment
         case 0x17: // copy uncompressed data from ROM to a RAM segment
         case 0x18: // decompress MIO0 data from ROM and copy it into a RAM segment
         case 0x1A: // decompress MIO0 data from ROM and copy it into a RAM segment (for texture only segments?)
            ptr_start = read_u32_be(&data[a+4]);
            ptr_end = read_u32_be(&data[a+8]);
            config_section_lookup(config, ptr_start, start_label, 0);
            config_section_lookup(config,   ptr_end,   end_label, 1);
            fprintf(out, ".word 0x");
            for (i = 0; i < 4; i++) {
               fprintf(out, "%02X", data[a+i]);
            }
            if (0 == strcmp("behavior_data", start_label)) {
               fprintf(out, ", __load_%s, __load_%s", start_label, end_label);
            } else {
               fprintf(out, ", %s, %s", start_label, end_label);
            }
            for (i = 12; i < data[a+1]; i++) {
               if ((i & 0x3) == 0) {
                  fprintf(out, ", 0x");
               }
               fprintf(out, "%02X", data[a+i]);
            }
            fprintf(out, "\n");
            break;
         case 0x11: // call function
         case 0x12: // call function
            ptr_start = read_u32_be(&data[a+0x4]);
            disasm_label_lookup(state, ptr_start, start_label);
            fprintf(out, ".word 0x%08X, %s # %08X\n", read_u32_be(&data[a]), start_label, ptr_start);
            break;
         case 0x16: // load ASM into RAM
            dst       = read_u32_be(&data[a+0x4]);
            ptr_start = read_u32_be(&data[a+0x8]);
            ptr_end   = read_u32_be(&data[a+0xc]);
            // TODO: differentiate between start/end
            disasm_label_lookup(state, dst, dst_label);
            config_section_lookup(config, ptr_start, start_label, 0);
            config_section_lookup(config, ptr_end, end_label, 1);
            fprintf(out, ".word 0x");
            for (i = 0; i < 4; i++) {
               fprintf(out, "%02X", data[a+i]);
            }
            fprintf(out, ", %s, %s, %s\n", dst_label, start_label, end_label);
            break;
         case 0x25: // load mario object with behavior
         case 0x24: // load object with behavior
            fprintf(out, ".word 0x%08X", read_u32_be(&data[a]));
            for (i = 4; i < data[a+1]-4; i+=4) {
               fprintf(out, ", 0x%08X", read_u32_be(&data[a+i]));
            }
            dst = read_u32_be(&data[a+i]);
            if (beh_i >= 0) {
               unsigned int offset = dst & 0xFFFFFF;
               split_section *beh = config->sections[beh_i].children;
               for (i = 0; i < config->sections[beh_i].child_count; i++) {
                  if (offset == beh[i].start) {
                     fprintf(out, ", %s", beh[i].label);
                     break;
                  }
               }
               if (i >= config->sections[beh_i].child_count) {
                  ERROR("Error: cannot find behavior %04X needed at offset %X\n", offset, a);
               }
            } else {
               fprintf(out, ", 0x%08X", dst);
            }
            fprintf(out, "\n");
            break;
         default:
            fprintf(out, ".word 0x%08X", read_u32_be(&data[a]));
            for (i = 4; i < data[a+1]; i+=4) {
               fprintf(out, ", 0x%08X", read_u32_be(&data[a+i]));
            }
            fprintf(out, "\n");
            break;
      }
      a += data[a+1];
   }
   // align to next 16-byte boundary
   if (a & 0x0F) {
      fprintf(out, "# begin %s alignment 0x%X\n", sec->label, a);
      fprintf(out, ".byte ");
      fprint_hex_source(out, &data[a], ALIGN(a, 16) - a);
      fprintf(out, "\n");
      a = ALIGN(a, 16);
   }
   // remaining is geo layout script
   fprintf(out, "# begin %s geo 0x%X\n", sec->label, a);
   write_geolayout(out, &data[sec->start], a - sec->start, sec->end - sec->start, state);
}

static void parse_music_sequences(FILE *out, unsigned char *data, split_section *sec, arg_config *args, strbuf *makeheader)
{
#define MUSIC_SUBDIR    "music"
   typedef struct {
      unsigned start;
      unsigned length;
   } sequence;
   typedef struct {
      unsigned revision;
      unsigned count;
      sequence *seq;
   } sequence_bank;

   char music_dir[FILENAME_MAX];
   char m64_file[FILENAME_MAX];
   char m64_file_rel[FILENAME_MAX];
   char seq_name[128];
   sequence_bank seq_bank = {0};
   unsigned i;

   sprintf(music_dir, "%s/%s", args->output_dir, MUSIC_SUBDIR);
   make_dir(music_dir);

   seq_bank.revision = read_u16_be(&data[sec->start]);
   seq_bank.count = read_u16_be(&data[sec->start+2]);
   if (seq_bank.count > 0) {
      seq_bank.seq = malloc(seq_bank.count * sizeof(*seq_bank.seq));
      for (i = 0; i < seq_bank.count; i++) {
         seq_bank.seq[i].start = read_u32_be(&data[sec->start+i*8+4]);
         seq_bank.seq[i].length = read_u32_be(&data[sec->start+i*8+8]);
      }
   }

   fprintf(out, "\n# music sequence table\n");
   fprintf(out, "music_sequence_table_header:\n");
   fprintf(out, ".hword %d, (music_sequence_table_end - music_sequence_table) / 8\n", seq_bank.revision);
   fprintf(out, "music_sequence_table:\n");
   for (i = 0; i < seq_bank.count; i++) {
      sprintf(seq_name, "seq_%02X", i);
      fprintf(out, ".word (%s - music_sequence_table_header), (%s_end - %s) # 0x%05X, 0x%04X\n",
              seq_name, seq_name, seq_name, seq_bank.seq[i].start, seq_bank.seq[i].length);
   }
   fprintf(out, "music_sequence_table_end:\n");
   fprintf(out, "\n.align 4, 0x01\n");
   for (i = 0; i < seq_bank.count; i++) {
      sprintf(seq_name, "seq_%02X", i);
      fprintf(out, "\n%s:", seq_name);

      sprintf(m64_file, "%s/%s.m64", music_dir, seq_name);
      write_file(m64_file, &data[sec->start + seq_bank.seq[i].start], seq_bank.seq[i].length);

      sprintf(m64_file_rel, "%s/%s.m64", MUSIC_SUBDIR, seq_name);
      fprintf(out, "\n.incbin \"%s\"\n", m64_file_rel);

      // append to Makefile
      strbuf_sprintf(makeheader, " \\\n$(MUSIC_DIR)/%s.m64", seq_name);

      fprintf(out, "%s_end:\n", seq_name);
   }

   // free used memory
   if (seq_bank.count > 0) {
      free(seq_bank.seq);
   }
}

static void parse_instrument_set(FILE *out, unsigned char *data, split_section *sec)
{
   unsigned *instrument_set;
   unsigned count;
   unsigned i, cur;

   count = sec->child_count;
   // each sequence has its own instrument set defined by offsets table
   instrument_set = malloc(count * sizeof(*instrument_set));
   for (i = 0; i < count; i++) {
      instrument_set[i] = read_u16_be(&data[sec->start + 2*i]);
   }
   fprintf(out, "\ninstrument_sets:\n");
   for (i = 0; i < count; i++) {
      fprintf(out, ".hword instrument_set_%02X - instrument_sets # 0x%04X\n", i, instrument_set[i]);
   }

   // output each instrument set
   cur = 0;
   for (i = 2*count; sec->start + i < sec->end; i++) {
      unsigned char val = data[sec->start + i];
      if (instrument_set[cur] == i) {
         fprintf(out, "\ninstrument_set_%02X:\n.byte 0x%02X", cur, val);
         cur++;
      } else {
         fprintf(out, ", 0x%02X", val);
      }
   }
   fprintf(out, "\ninstrument_sets_end:\n");
}

static void generate_globals(arg_config *args, rom_config *config)
{
   char globalfilename[FILENAME_MAX];
   FILE *fglobal;
   sprintf(globalfilename, "%s/%s", args->output_dir, GLOBALS_FILE);
   fglobal = fopen(globalfilename, "w");
   if (fglobal == NULL) {
      ERROR("Error opening %s\n", globalfilename);
      exit(3);
   }
   fprintf(fglobal, "# globally accessible functions and data\n"
                    "# these will be accessible by C code and show up in the .map file\n\n");
   for (int i = 0; i < config->label_count; i++) {
      fprintf(fglobal, ".global %s\n", config->labels[i].name);
   }
   fprintf(fglobal, "\n");

   fclose(fglobal);
}

static void generate_macros(arg_config *args)
{
   char incfilename[FILENAME_MAX];
   FILE *finc;
   sprintf(incfilename, "%s/%s", args->output_dir, MACROS_FILE);
   finc = fopen(incfilename, "w");
   if (finc == NULL) {
      ERROR("Error opening %s\n", incfilename);
      exit(3);
   }
   fprintf(finc, "# common macros\n"
                 "\n"
                 "# F3D vertex\n"
                 ".macro vertex \\x, \\y, \\z, \\u, \\v, \\r=0xFF, \\g=0xFF, \\b=0xFF, \\a=0xFF\n"
                 "   .hword \\x, \\y, \\z, 0, \\u, \\v\n   .byte \\r, \\g, \\b, \\a\n"
                 ".endm\n");
   fclose(finc);
}

static void parse_sound_banks(FILE *out, unsigned char *data, split_section *secCtl, split_section *secTbl, arg_config *args, strbuf *makeheader)
{
#define SOUNDS_SUBDIR    "sounds"
   // TODO: unused parameters
   (void)out;
   (void)makeheader;

   char sound_dir[FILENAME_MAX];
   char sfx_file[FILENAME_MAX];
   unsigned i, j, sound_count;

   sfx_initialize_key_table();
   
   sprintf(sound_dir, "%s/%s", args->output_dir, SOUNDS_SUBDIR);
   make_dir(sound_dir);

   sound_data_header sound_data = read_sound_data(data, secTbl->start);
   sound_bank_header sound_banks = read_sound_bank(data, secCtl->start);
   
   sound_count = 0;
   
   for (i = 0; i < sound_banks.bank_count; i++) {
      for (j = 0; j < sound_banks.banks[i].instrument_count; j++) {
        if(sound_banks.banks[i].sounds[j].wav_prev != NULL) {
          sprintf(sfx_file, "Bank%uSound%uPrev", i, j);
          extract_raw_sound(sound_dir, sfx_file, sound_banks.banks[i].sounds[j].wav_prev, sound_banks.banks[i].sounds[j].key_base_prev, sound_data.data[i], 16000);
          sound_count++;
       }
        if(sound_banks.banks[i].sounds[j].wav != NULL) {
          sprintf(sfx_file, "Bank%uSound%u", i, j);
          extract_raw_sound(sound_dir, sfx_file, sound_banks.banks[i].sounds[j].wav, sound_banks.banks[i].sounds[j].key_base, sound_data.data[i], 16000);
          sound_count++;
       }
        if(sound_banks.banks[i].sounds[j].wav_sec != NULL) {
          sprintf(sfx_file, "Bank%uSound%uSec", i, j);
          extract_raw_sound(sound_dir, sfx_file, sound_banks.banks[i].sounds[j].wav_sec, sound_banks.banks[i].sounds[j].key_base_sec, sound_data.data[i], 16000);
          sound_count++;
       }
     }
     
     // Todo: add percussion export here
   }

   // free used memory
   if (sound_banks.bank_count > 0) {
      free(sound_banks.banks);
   }
   
   INFO("Successfully exported sounds:\n");
   INFO("  # of banks: %u\n", sound_banks.bank_count);
   INFO("  # of sounds: %u\n", sound_count);
}

static void generate_geo_macros(arg_config *args)
{
   char macrofilename[FILENAME_MAX];
   FILE *fmacro;
   sprintf(macrofilename, "%s/geo_commands.inc", args->output_dir);
   fmacro = fopen(macrofilename, "w");
   if (fmacro == NULL) {
      ERROR("Error opening %s\n", macrofilename);
      exit(3);
   }
   fprintf(fmacro,
"# geo layout macros\n"
"\n"
"# 0x00: Branch and store return address\n"
"#   0x04: scriptTarget, segment address of geo layout\n"
".macro geo_branch_and_link scriptTarget\n"
"    .byte 0x00, 0x00, 0x00, 0x00\n"
"    .word \\scriptTarget\n"
".endm\n"
"\n"
"# 0x01: Terminate geo layout\n"
"#   0x01-0x03: unused\n"
".macro geo_end\n"
"    .byte 0x01, 0x00, 0x00, 0x00\n"
".endm\n"
"\n"
"# 0x02: Branch\n"
"#   0x01: if 1, store next geo layout address on stack\n"
"#   0x02-0x03: unused\n"
"#   0x04: scriptTarget, segment address of geo layout\n"
".macro geo_branch type, scriptTarget\n"
"    .byte 0x02, \\type, 0x00, 0x00\n"
"    .word \\scriptTarget\n"
".endm\n"
"\n"
"# 0x03: Return from branch\n"
"#   0x01-0x03: unused\n"
".macro geo_return\n"
"    .byte 0x03, 0x00, 0x00, 0x00\n"
".endm\n"
"\n"
"# 0x04: Open node\n"
"#   0x01-0x03: unused\n"
".macro geo_open_node\n"
"    .byte 0x04, 0x00, 0x00, 0x00\n"
".endm\n"
"\n"
"# 0x05: Close node\n"
"#   0x01-0x03: unused\n"
".macro geo_close_node\n"
"    .byte 0x05, 0x00, 0x00, 0x00\n"
".endm\n"
"\n"
"# 0x06: TODO\n"
"#   0x01: unused\n"
"#   0x02: s16, index of some array\n"
".macro geo_todo_06 param\n"
"    .byte 0x06, 0x00\n"
"    .hword \\param\n"
".endm\n"
"\n"
"# 0x07: Update current scene graph node flags\n"
"#   0x01: u8 operation (0 = reset, 1 = set, 2 = clear)\n"
"#   0x02: s16 bits\n"
".macro geo_update_node_flags operation, flagBits\n"
"    .byte 0x07, \\operation\n"
"    .hword \\flagBits\n"
".endm\n"
"\n"
"# 0x08: Create screen area scene graph node\n"
"#   0x01: unused\n"
"#   0x02: s16 num entries (+2) to allocate\n"
"#   0x04: s16 x\n"
"#   0x06: s16 y\n"
"#   0x08: s16 width\n"
"#   0x0A: s16 height\n"
".macro geo_node_screen_area numEntries, x, y, width, height\n"
"    .byte 0x08, 0x00\n"
"    .hword \\numEntries\n"
"    .hword \\x, \\y, \\width, \\height\n"
".endm\n"
"\n"
"# 0x09: TODO Create ? scene graph node\n"
"#   0x02: s16 ?\n"
".macro geo_todo_09 param\n"
"    .byte 0x09, 0x00\n"
"    .hword \\param\n"
".endm\n"
"\n"
"# 0x0A: Create camera frustum scene graph node\n"
"#   0x01: u8  if nonzero, enable function field\n"
"#   0x02: s16 field of view\n"
"#   0x04: s16 near\n"
"#   0x06: s16 far\n"
"#   0x08: [GraphNodeFunc function]\n"
".macro geo_camera_frustum fov, near, far, function=0\n"
"    .byte 0x0A\n"
"    .if (\\function != 0)\n"
"       .byte 0x01\n"
"    .else\n"
"       .byte 0x00\n"
"    .endif\n"
"    .hword \\fov, \\near, \\far\n"
"    .if (\\function != 0)\n"
"       .word \\function\n"
"    .endif\n"
".endm\n"
"\n"
"# 0x0B: Create a root scene graph node\n"
"#   0x01-0x03: unused\n"
".macro geo_node_start\n"
"    .byte 0x0B, 0x00, 0x00, 0x00\n"
".endm\n"
"\n"
"# 0x0C: Create zbuffer-toggling scene graph node\n"
"#   0x01: u8 enableZBuffer (1 = on, 0 = off)\n"
"#   0x02-0x03: unused\n"
".macro geo_zbuffer enable\n"
"    .byte 0x0C, \\enable, 0x00, 0x00\n"
".endm\n"
"\n"
"# 0x0D: Create render range scene graph node\n"
"#   0x01-0x03: unused\n"
"#   0x04: s16 minDistance\n"
"#   0x06: s16 maxDistance\n"
".macro geo_render_range minDistance, maxDistance\n"
"    .byte 0x0D, 0x00, 0x00, 0x00\n"
"    .hword \\minDistance, \\maxDistance\n"
".endm\n"
"\n"
"# 0x0E: Create switch-case scene graph node\n"
"#   0x01: unused\n"
"#   0x02: s16 numCases\n"
"#   0x04: GraphNodeFunc caseSelectorFunc\n"
".macro geo_switch_case count, function\n"
"    .byte 0x0E, 0x00\n"
"    .hword \\count\n"
"    .word \\function\n"
".endm\n"
"\n"
"# 0x0F: TODO Create ? scene graph node\n"
"#   0x01: unused\n"
"#   0x02: s16 ?\n"
"#   0x04: s16 unkX\n"
"#   0x06: s16 unkY\n"
"#   0x08: s16 unkZ\n"
"#   0x0A: s16 unkX_2\n"
"#   0x0C: s16 unkY_2\n"
"#   0x0E: s16 unkZ_2\n"
"#   0x10: GraphNodeFunc function\n"
".macro geo_todo_0F unknown, x1, y1, z1, x2, y2, z2, function\n"
"    .byte 0x0F, 0x00\n"
"    .hword \\unknown, \\x1, \\y1, \\z1, \\x2, \\y2, \\z2\n"
"    .word \\function\n"
".endm\n"
"\n"
"# 0x10: Create translation & rotation scene graph node with optional display list\n"
"# Four different versions of 0x10\n"
"#   cmd+0x01: u8 params\n"
"#     0b1000_0000: if set, enable displayList field and drawingLayer\n"
"#     0b0111_0000: fieldLayout (determines how rest of data is formatted\n"
"#     0b0000_1111: drawingLayer\n"
"#\n"
"#   fieldLayout = 0: Translate & Rotate\n"
"#     0x04: s16 xTranslation\n"
"#     0x06: s16 xTranslation\n"
"#     0x08: s16 xTranslation\n"
"#     0x0A: s16 xRotation\n"
"#     0x0C: s16 xRotation\n"
"#     0x0E: s16 xRotation\n"
"#     0x10: [u32 displayList: if MSbit of params set, display list segmented address]\n"
".macro geo_translate_rotate layer, tx, ty, tz, rx, ry, rz, displayList=0\n"
"    .byte 0x10\n"
"    .if (\\displayList != 0)\n"
"        .byte 0x00 | \\layer | 0x80\n"
"    .else\n"
"        .byte 0x00 | \\layer\n"
"    .endif\n"
"    .hword 0x0000\n"
"    .hword \\tx, \\ty, \\tz\n"
"    .hword \\rx, \\ry, \\rz\n"
"    .if (\\displayList != 0)\n"
"        .word \\displayList\n"
"    .endif\n"
".endm\n"
"\n"
"#   fieldLayout = 1: Translate\n"
"#     0x02: s16 xTranslation\n"
"#     0x04: s16 yTranslation\n"
"#     0x06: s16 zTranslation\n"
"#     0x08: [u32 displayList: if MSbit of params set, display list segmented address]\n"
".macro geo_translate layer, tx, ty, tz, displayList=0\n"
"    .byte 0x10\n"
"    .if (\\displayList != 0)\n"
"        .byte 0x10 | \\layer | 0x80\n"
"    .else\n"
"        .byte 0x10 | \\layer\n"
"    .endif\n"
"    .hword \\tx, \\ty, \\tz\n"
"    .if (\\displayList != 0)\n"
"        .word \\displayList\n"
"    .endif\n"
".endm\n"
"\n"
"#   fieldLayout = 2: Rotate\n"
"#     0x02: s16 xRotation\n"
"#     0x04: s16 yRotation\n"
"#     0x06: s16 zRotation\n"
"#     0x08: [u32 displayList: if MSbit of params set, display list segmented address]\n"
".macro geo_rotate layer, rx, ry, rz, displayList=0\n"
"    .byte 0x10\n"
"    .if (\\displayList != 0)\n"
"        .byte 0x20 | \\layer | 0x80\n"
"    .else\n"
"        .byte 0x20 | \\layer\n"
"    .endif\n"
"    .hword \\rx, \\ry, \\rz\n"
"    .if (\\displayList != 0)\n"
"        .word \\displayList\n"
"    .endif\n"
".endm\n"
"\n"
"#   fieldLayout = 3: Rotate Y\n"
"#     0x02: s16 yRotation\n"
"#     0x04: [u32 displayList: if MSbit of params set, display list segmented address]\n"
".macro geo_rotate_y layer, ry, displayList=0\n"
"    .byte 0x10\n"
"    .if (\\displayList != 0)\n"
"        .byte 0x30 | \\layer | 0x80\n"
"    .else\n"
"        .byte 0x30 | \\layer\n"
"    .endif\n"
"    .hword \\ry\n"
"    .if (\\displayList != 0)\n"
"        .word \\displayList\n"
"    .endif\n"
".endm\n"
"\n"
"# 0x11: TODO Create ? scene graph node with optional display list\n"
"#   0x01: u8 params\n"
"#     0b1000_0000: if set, enable displayList field and drawingLayer\n"
"#     0b0000_1111: drawingLayer\n"
"#   0x02: s16 unkX\n"
"#   0x04: s16 unkY\n"
"#   0x06: s16 unkZ\n"
"#   0x08: [u32 displayList: if MSbit of params set, display list segmented address]\n"
".macro geo_todo_11 layer, ux, uy, uz, displayList=0\n"
"    .byte 0x11\n"
"    .if (\\displayList != 0)\n"
"        .byte 0x80 | \\layer\n"
"    .else\n"
"        .byte 0x00\n"
"    .endif\n"
"    .hword \\ux, \\uy, \\uz\n"
"    .if (\\displayList != 0)\n"
"        .word \\displayList\n"
"    .endif\n"
".endm\n"
"\n"
"# 0x12: TODO Create ? scene graph node\n"
"#   0x01: u8 params\n"
"#      0b1000_0000: if set, enable displayList field and drawingLayer\n"
"#      0b0000_1111: drawingLayer\n"
"#   0x02: s16 unkX\n"
"#   0x04: s16 unkY\n"
"#   0x06: s16 unkZ\n"
"#   0x08: [u32 displayList: if MSbit of params set, display list segmented address]\n"
".macro geo_todo_12 layer, ux, uy, uz, displayList=0\n"
"    .byte 0x12\n"
"    .if (\\displayList != 0)\n"
"        .byte 0x80 | \\layer\n"
"    .else\n"
"        .byte 0x00\n"
"    .endif\n"
"    .hword \\ux, \\uy, \\uz\n"
"    .if (\\displayList != 0)\n"
"        .word \\displayList\n"
"    .endif\n"
".endm\n"
"\n"
"# 0x13: Create display list scene graph node with translation\n"
"#   0x01: u8 drawingLayer\n"
"#   0x02: s16 xTranslation\n"
"#   0x04: s16 yTranslation\n"
"#   0x06: s16 zTranslation\n"
"#   0x08: u32 displayList: dislay list segmented address\n"
".macro geo_dl_translated layer, x, y, z, displayList=0\n"
"    .byte 0x13, \\layer\n"
"    .hword \\x, \\y, \\z\n"
"    .word \\displayList\n"
".endm\n"
"\n"
"# 0x14: Create billboarding node with optional display list\n"
"#   0x01: u8 params\n"
"#      0b1000_0000: if set, enable displayList field and drawingLayer\n"
"#      0b0000_1111: drawingLayer\n"
"#   0x02: s16 xTranslation\n"
"#   0x04: s16 yTranslation\n"
"#   0x06: s16 zTranslation\n"
"#   0x08: [u32 displayList: if MSbit of params is set, display list segmented address]\n"
".macro geo_billboard layer=0, tx=0, ty=0, tz=0, displayList=0\n"
"    .byte 0x14\n"
"    .if (\\displayList != 0)\n"
"        .byte 0x80 | \\layer\n"
"    .else\n"
"        .byte 0x00\n"
"    .endif\n"
"    .hword \\tx, \\ty, \\tz\n"
"    .if (\\displayList != 0)\n"
"        .word \\displayList\n"
"    .endif\n"
".endm\n"
"\n"
"# 0x15: Create plain display list scene graph node\n"
"#   0x01: u8 drawingLayer\n"
"#   0x02=0x03: unused\n"
"#   0x04: u32 displayList: display list segmented address\n"
".macro geo_display_list layer, displayList\n"
"    .byte 0x15, \\layer, 0x00, 0x00\n"
"    .word \\displayList\n"
".endm\n"
"\n"
"# 0x16: Create shadow scene graph node\n"
"#   0x01: unused\n"
"#   0x02: s16 shadowType (cast to u8)\n"
"#   0x04: s16 shadowSolidity (cast to u8)\n"
"#   0x06: s16 shadowScale\n"
".set SHADOW_CIRCLE_UNK0,      0x00\n"
".set SHADOW_CIRCLE_UNK1,      0x01\n"
".set SHADOW_CIRCLE_UNK2,      0x02  # unused shadow type\n"
".set SHADOW_SQUARE_PERMANENT, 0x0A  # square shadow that never disappears\n"
".set SHADOW_SQUARE_SCALABLE,  0x0B  # square shadow, shrinks with distance\n"
".set SHADOW_SQUARE_TOGGLABLE, 0x0C  # square shadow, disappears with distance\n"
".set SHADOW_CIRCLE_PLAYER,    0x63  # player (Mario) shadow\n"
".set SHADOW_RECTANGLE_HARDCODED_OFFSET, 0x32 # offset of hard-coded shadows\n"
".macro geo_shadow type, solidity, scale\n"
"    .byte 0x16, 0x00\n"
"    .hword \\type, \\solidity, \\scale\n"
".endm\n"
"\n"
"# 0x17: TODO Create ? scene graph node\n"
"#   0x01-0x03: unused\n"
".macro geo_todo_17\n"
"    .byte 0x17, 0x00, 0x00, 0x00\n"
".endm\n"
"\n"
"# 0x18: Create ? scene graph node\n"
"#   0x01: unused\n"
"#   0x02: s16 parameter\n"
"#   0x04: GraphNodeFunc function\n"
".macro geo_asm param, function\n"
"    .byte 0x18, 0x00\n"
"    .hword \\param\n"
"    .word \\function\n"
".endm\n"
"\n"
"# 0x19: Create background scene graph node\n"
"#   0x02: s16 background: background ID, or RGBA5551 color if backgroundFunc is null\n"
"#   0x04: GraphNodeFunc backgroundFunc\n"
".macro geo_background param, function=0\n"
"    .byte 0x19, 0x00\n"
"    .hword \\param\n"
"    .word \\function\n"
".endm\n"
"\n"
"# 0x1A: No operation\n"
".macro geo_nop_1A\n"
"    .byte 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n"
".endm\n"
"\n"
"# 0x1B: TODO Create ? scene graph node\n"
"#   0x02: s16 index of array\n"
".macro geo_todo_1B param\n"
"    .byte 0x1B, 0x00\n"
"    .hword \\param\n"
".endm\n"
"\n"
"# 0x1C: TODO Create ? scene graph node\n"
"#   0x01: u8 unk01\n"
"#   0x02: s16 unkX\n"
"#   0x04: s16 unkY\n"
"#   0x06: s16 unkZ\n"
"#   0x08: GraphNodeFunc nodeFunc\n"
".macro geo_todo_1C param, ux, uy, uz, nodeFunc\n"
"    .byte 0x1C, \\param\n"
"    .hword \\ux, \\uy, \\uz\n"
"    .word \\nodeFunc\n"
".endm\n"
"\n"
"# 0x1D: Create scale scene graph node with optional display list\n"
"#   0x01: u8 params\n"
"#     0b1000_0000: if set, enable displayList field and drawingLayer\n"
"#     0b0000_1111: drawingLayer\n"
"#   0x02-0x03: unused\n"
"#   0x04: u32 scale (0x10000 = 1.0)\n"
"#   0x08: [u32 displayList: if MSbit of params is set, display list segment address]\n"
".macro geo_scale layer, scale, displayList=0\n"
"    .byte 0x1D\n"
"    .if (\\displayList != 0)\n"
"        .byte 0x80 | \\layer\n"
"    .else\n"
"        .byte 0x00\n"
"    .endif\n"
"    .byte 0x00, 0x00\n"
"    .word \\scale\n"
"    .if (\\displayList != 0)\n"
"        .word \\displayList\n"
"    .endif\n"
".endm\n"
"\n"
"# 0x1E: No operation\n"
".macro geo_nop_1E\n"
"    .byte 0x1E, 0x00, 0x00, 0x00\n"
"    .byte 0x00, 0x00, 0x00, 0x00\n"
".endm\n"
"\n"
"# 0x1F: No operation\n"
".macro geo_nop_1F\n"
"    .byte 0x1F, 0x00, 0x00, 0x00\n"
"    .byte 0x00, 0x00, 0x00, 0x00\n"
"    .byte 0x00, 0x00, 0x00, 0x00\n"
"    .byte 0x00, 0x00, 0x00, 0x00\n"
".endm\n"
"\n"
"# 0x20: Create render distance scene graph node (unconfirmed?)\n"
"#   0x01: unused\n"
"#   0x02: s16 renderDistance?\n"
".macro geo_start_distance renderDistance\n"
"    .byte 0x20, 0x00\n"
"    .hword \\renderDistance\n"
".endm\n"
"\n"
   );
}

static void generate_ld_script(arg_config *args, rom_config *config)
{
   char ldfilename[FILENAME_MAX];
   FILE *fld;
   sprintf(ldfilename, "%s/%s.ld", args->output_dir, config->basename);
   fld = fopen(ldfilename, "w");
   if (fld == NULL) {
      ERROR("Error opening %s\n", ldfilename);
      exit(3);
   }
   fprintf(fld,
"/* %s linker script\n"
" * generated by n64split v%s - N64 ROM splitter */\n"
"\n"
"OUTPUT_FORMAT (\"elf32-bigmips\", \"elf32-bigmips\", \"elf32-littlemips\")\n"
"OUTPUT_ARCH (mips)\n"
"\n"
"SECTIONS\n"
"{\n"
"   /* header and boot */\n"
"   .header 0x0 : AT(0x0) {\n"
"      * (.header);\n"
"      * (.boot);\n"
"   }\n"
"\n"
"   /* load MIO0 and level data at 0x800000 */\n"
"   .rodata 0x800000 : {\n"
"      FILL (0x01) /* fill unused with 0x01 */\n"
"      * (.mio0);\n"
"      * (.rodata);\n"
"      * (.data);\n"
"      * (.MIPS.abiflags);\n"
"      . = ALIGN(0x10);\n"
"   }\n"
"\n"
"   /* use segmented addressing for behaviors */\n"
"   .behavior 0x13000000 : AT( LOADADDR(.rodata) + SIZEOF(.rodata) ) {\n"
"      FILL (0x01) /* fill unused with 0x01 */\n"
"      * (.behavior);\n"
"      behavior_length = . - 0x13000000;\n"
"      /* default 4MB data (12MB ROM) */\n"
"      . = 0x400000 - SIZEOF(.rodata);\n"
"   }\n"
"   __load_behavior_data = LOADADDR(.behavior);\n"
"   __load_behavior_data_end = LOADADDR(.behavior) + behavior_length;\n"
"\n", config->name, N64SPLIT_VERSION);
   for (int i = 0; i < config->section_count; i++) {
      split_section *s = &config->sections[i];
      if (s->type == TYPE_ASM) {
         unsigned int rom_start = s->start;
         unsigned int rom_end = s->end;
         unsigned int ram_start = s->vaddr;
         unsigned int length = rom_end - rom_start;
         fprintf(fld,
"   /* 0x%08X %06X-%06X [%X] */\n"
"   .text%08X 0x%08X : AT(0x%06X) {\n"
"      * (.text%08X);\n"
"   }\n"
"\n", ram_start, rom_start, rom_end, length,
      ram_start, ram_start, rom_start, ram_start);
      }
   }
   fprintf(fld, "}\n");

   fclose(fld);
}

typedef struct
{
   unsigned type;
   char *name;
} terrain_t;

static const terrain_t terrain_table[] =
{
   {0x0000, "normal"},
   {0x0001, "lethal_lava"},
   {0x0005, "hang"},
   {0x000A, "deathfloor"},
   {0x000E, "water_currents"},
   {0x0012, "void"},
   {0x0013, "very_slippery"},
   {0x0014, "slippery"},
   {0x0015, "climbable"},
   {0x0028, "wall"},
   {0x0029, "grass"},
   {0x002A, "unclimbable"},
   {0x002C, "windy"},
   {0x002E, "icy"},
   {0x0030, "flat"},
   {0x0036, "snowy"},
   {0x0037, "snowy2"},
   {0x0076, "fence"},
   {0x007B, "vanishing_wall"},
   {0x00FD, "pool_warp"},
};

char *terrain2str(unsigned type)
{
   unsigned i;
   static char retval[16];
   if (0x1B <= type && type <= 0x1E) {
      sprintf(retval, "switch%02X", type);
      return retval;
   } else if (0xA6 <= type && type <= 0xCF) {
      sprintf(retval, "paintingf%02X", type);
      return retval;
   } else if (0xD3 <= type && type <= 0xF8) {
      sprintf(retval, "paintingb%02X", type);
      return retval;
   }
   for (i = 0; i < DIM(terrain_table); i++) {
      if (terrain_table[i].type == type) {
         return terrain_table[i].name;
      }
   }
   sprintf(retval, "%02X", type);
   return retval;
}

int collision2obj(char *binfilename, unsigned int binoffset, char *objfilename, char *name, float scale)
{
   unsigned char *data;
   FILE *fobj;
   long in_size;
   unsigned vcount;
   unsigned tcount;
   unsigned cur_tcount;
   unsigned terrain;
   unsigned v_per_t;
   unsigned processing;
   unsigned offset;
   unsigned i;
   unsigned vidx[3];
   short x, y, z;
   int ret_len = 0;

   fobj = fopen(objfilename, "w");
   if (fobj == NULL) {
      ERROR("Error opening \"%s\" for writing\n", objfilename);
      exit(EXIT_FAILURE);
   }

   in_size = read_file(binfilename, &data);
   if (in_size <= 0) {
      ERROR("Error reading input file \"%s\"\n", binfilename);
      exit(EXIT_FAILURE);
   }

   offset = binoffset;
   if (data[offset] != 0x00 || data[offset+1] != 0x40) {
      ERROR("Unknown collision data %s.%X: %08X\n", name, offset, read_u32_be(data));
      return 0;
   }

   fprintf(fobj, "# collision model generated from n64split v%s\n"
                 "# level %s %05X\n"
                 "\n"
                 "mtllib collision.mtl\n\n", N64SPLIT_VERSION, name, binoffset);
   vcount = read_u16_be(&data[offset+2]);
   INFO("Loading %u vertices\n", vcount);
   offset += 4;
   for (i = 0; i < vcount; i++) {
      x = read_s16_be(&data[offset + i*6]);
      y = read_s16_be(&data[offset + i*6+2]);
      z = read_s16_be(&data[offset + i*6+4]);
      fprintf(fobj, "v %f %f %f\n", (float)x/scale, (float)y/scale, (float)z/scale);
   }
   offset += vcount*6;
   tcount = 0;
   processing = 1;
   while (processing) {
      terrain = read_u16_be(&data[offset]);
      cur_tcount = read_u16_be(&data[offset+2]);
      // 0041 indicates the end, followed by 0042 or 0043
      if (terrain == 0x41 || terrain > 0xFF) {
         processing = 0;
         break;
      }
      switch (terrain) {
         case 0x0E:
         case 0x2C:
         case 0x24:
         case 0x25:
         case 0x27:
         case 0x2D:
            v_per_t = 4;
            break;
         default:
            v_per_t = 3;
            break;
      }
      fprintf(fobj, "\ng %s_%05X_%s\n", name, binoffset, terrain2str(terrain));
      fprintf(fobj, "usemtl %s\n", terrain2str(terrain));

      INFO("Loading %u triangles of terrain %02X\n", cur_tcount, terrain);
      offset += 4;
      for (i = 0; i < cur_tcount; i++) {
         vidx[0] = read_u16_be(&data[offset + i*v_per_t*2]);
         vidx[1] = read_u16_be(&data[offset + i*v_per_t*2+2]);
         vidx[2] = read_u16_be(&data[offset + i*v_per_t*2+4]);
         fprintf(fobj, "f %d %d %d\n", vidx[0]+1, vidx[1]+1, vidx[2]+1);
      }
      tcount += cur_tcount;
      offset += cur_tcount*v_per_t*2;
   }

   fclose(fobj);
   free(data);

   ret_len = offset - binoffset;
   return ret_len;
}

static void split_file(unsigned char *data, unsigned int length, arg_config *args, rom_config *config, disasm_state *state)
{
#define BIN_SUBDIR      "bin"
#define MIO0_SUBDIR     "bin"
#define TEXTURE_SUBDIR  "textures"
#define GEO_SUBDIR      "geo"
#define LEVEL_SUBDIR    "levels"
#define MODEL_SUBDIR    "models"
#define BEHAVIOR_SUBDIR "."
   char makefile_name[FILENAME_MAX];
   char bin_dir[FILENAME_MAX];
   char mio0_dir[FILENAME_MAX];
   char texture_dir[FILENAME_MAX];
   char geo_dir[FILENAME_MAX];
   char level_dir[FILENAME_MAX];
   char model_dir[FILENAME_MAX];
   char behavior_dir[FILENAME_MAX];
   char asmfilename[FILENAME_MAX];
   char outfilename[FILENAME_MAX];
   char outfilepath[FILENAME_MAX];
   char mio0filename[FILENAME_MAX];
   char start_label[256];
   strbuf makeheader_mio0;
   strbuf makeheader_level;
   strbuf makeheader_music;
   FILE *fasm;
   FILE *fmake;
   int s;
   int i;
   unsigned int a;
   unsigned int w, h;
   unsigned int prev_end = 0;
   unsigned int ptr;
   split_section *sections = config->sections;

   // create directories
   sprintf(makefile_name, "%s/Makefile.split", args->output_dir);
   sprintf(bin_dir, "%s/%s", args->output_dir, BIN_SUBDIR);
   sprintf(mio0_dir, "%s/%s", args->output_dir, MIO0_SUBDIR);
   sprintf(texture_dir, "%s/%s", args->output_dir, TEXTURE_SUBDIR);
   sprintf(geo_dir, "%s/%s", args->output_dir, GEO_SUBDIR);
   sprintf(level_dir, "%s/%s", args->output_dir, LEVEL_SUBDIR);
   sprintf(model_dir, "%s/%s", args->output_dir, MODEL_SUBDIR);
   sprintf(behavior_dir, "%s/%s", args->output_dir, BEHAVIOR_SUBDIR);
   make_dir(args->output_dir);
   make_dir(bin_dir);
   make_dir(mio0_dir);
   make_dir(texture_dir);
   make_dir(geo_dir);
   make_dir(level_dir);
   make_dir(model_dir);
   make_dir(behavior_dir);

   // open main assembly file and write header
   sprintf(asmfilename, "%s/%s.s", args->output_dir, config->basename);
   fasm = fopen(asmfilename, "w");
   if (fasm == NULL) {
      ERROR("Error opening %s\n", asmfilename);
      exit(3);
   }
   fprintf(fasm, asm_header, config->name, N64SPLIT_VERSION);

   // generate globals include file
   generate_globals(args, config);
   // generate common macros
   generate_macros(args);

   strbuf_alloc(&makeheader_music, 256);
   strbuf_sprintf(&makeheader_music, "MUSIC_FILES =");

   //Need both sfx sections to parse
   split_section *sfxSec = NULL;
   
   for (s = 0; s < config->section_count; s++) {
      split_section *sec = &sections[s];

      // error checking
      if (sec->start >= length || sec->end > length) {
         ERROR("Error: section past end: 0x%X, 0x%X (%s) > 0x%X\n",
               sec->start, sec->end, sec->label ? sec->label : "", length);
         exit(4);
      }

      // fill gaps between regions
      if (sec->start != prev_end) {
         int gap_len = sec->start - prev_end;
         INFO("Filling gap before region %d (%d bytes)\n", s, gap_len);
         fprintf(fasm, "# Unknown region %06X-%06X [%X]\n", prev_end, sec->start, gap_len);
         // for small gaps, just output bytes
         if (gap_len <= 0x80) {
            unsigned int group_offset = prev_end;
            while (gap_len > 0) {
               int group_len = MIN(gap_len, 0x10);
               fprintf(fasm, ".byte ");
               fprint_hex_source(fasm, &data[group_offset], group_len);
               fprintf(fasm, "\n");
               gap_len -= group_len;
               group_offset += group_len;
            }
         } else {
            sprintf(outfilename, "%s/%s.%06X.bin", BIN_SUBDIR, config->basename, prev_end);
            sprintf(outfilepath, "%s/%s", args->output_dir, outfilename);
            write_file(outfilepath, &data[prev_end], gap_len);
            fprintf(fasm, ".incbin \"%s\"\n", outfilename);
         }
         fprintf(fasm, "\n");
      }

      switch (sec->type)
      {
         case TYPE_HEADER:
            INFO("Section header: %X-%X\n", sec->start, sec->end);
            fprintf(fasm, ".section .header, \"a\"\n"
                          ".byte  0x%02X", data[sec->start]);
            for (i = 1; i < 4; i++) {
               fprintf(fasm, ", 0x%02X", data[sec->start + i]);
            }
            fprintf(fasm, " # PI BSD Domain 1 register\n");
            fprintf(fasm, ".word  0x%08X # clock rate setting\n", read_u32_be(&data[sec->start + 0x4]));
            fprintf(fasm, ".word  0x%08X # entry point\n", read_u32_be(&data[sec->start + 0x8]));
            fprintf(fasm, ".word  0x%08X # release\n", read_u32_be(&data[sec->start + 0xc]));
            fprintf(fasm, ".word  0x%08X # checksum1\n", read_u32_be(&data[sec->start + 0x10]));
            fprintf(fasm, ".word  0x%08X # checksum2\n", read_u32_be(&data[sec->start + 0x14]));
            fprintf(fasm, ".word  0x%08X # unknown\n", read_u32_be(&data[sec->start + 0x18]));
            fprintf(fasm, ".word  0x%08X # unknown\n", read_u32_be(&data[sec->start + 0x1C]));
            fprintf(fasm, ".ascii \"");
            fwrite(&data[sec->start + 0x20], 1, 20, fasm);
            fprintf(fasm, "\" # ROM name: 20 bytes\n");
            fprintf(fasm, ".word  0x%08X # unknown\n", read_u32_be(&data[sec->start + 0x34]));
            fprintf(fasm, ".word  0x%08X # cartridge\n", read_u32_be(&data[sec->start + 0x38]));
            fprintf(fasm, ".ascii \"");
            fwrite(&data[sec->start + 0x3C], 1, 2, fasm);
            fprintf(fasm, "\"       # cartridge ID\n");
            fprintf(fasm, ".ascii \"");
            fwrite(&data[sec->start + 0x3E], 1, 1, fasm);
            fprintf(fasm, "\"        # country\n");
            fprintf(fasm, ".byte  0x%02X       # version\n\n", data[sec->start + 0x3F]);
            break;
         case TYPE_BIN:
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(outfilename, "%s/%s.%06X.bin", BIN_SUBDIR, config->basename, sec->start);
            } else {
               sprintf(outfilename, "%s/%s.%06X.%s.bin", BIN_SUBDIR, config->basename, sec->start, sec->label);
            }
            sprintf(outfilepath, "%s/%s", args->output_dir, outfilename);
            write_file(outfilepath, &data[sec->start], sec->end - sec->start);
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(start_label, "L%06X", sec->start);
            } else {
               strcpy(start_label, sec->label);
            }
            fprintf(fasm, "%s:\n", start_label);
            fprintf(fasm, ".incbin \"%s\"\n", outfilename);
            fprintf(fasm, "%s_end:\n", start_label);
            break;
         case TYPE_BLAST:
         case TYPE_MIO0:
         case TYPE_GZIP:
         case TYPE_SM64_GEO:
            // fill previous geometry and MIO0 blocks
            fprintf(fasm, ".space 0x%05x, 0x01 # %s\n", sec->end - sec->start, sec->label);
            break;
         case TYPE_PTR:
            INFO("Section ptr: %X-%X\n", sec->start, sec->end);
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(start_label, "Ptr%06X", sec->start);
            } else {
               strcpy(start_label, sec->label);
            }
            fprintf(fasm, "%s:\n", start_label);
            for (a = sec->start; a < sec->end; a += 4) {
               ptr = read_u32_be(&data[a]);
               disasm_label_lookup(state, ptr, start_label);
               fprintf(fasm, ".word %s", start_label);
               if (sec->child_count > 0) {
                  for (i = 1; i < sec->child_count; i++) {
                     a += 4;
                     ptr = read_u32_be(&data[a]);
                     disasm_label_lookup(state, ptr, start_label);
                     fprintf(fasm, ", %s", start_label);
                  }
               }
               fprintf(fasm, "\n");
            }
            fprintf(fasm, "\n");
            break;
         case TYPE_ASM:
            INFO("Section asm: %X-%X\n", sec->start, sec->end);
            fprintf(fasm, "\n.section .text%08X, \"ax\"\n\n", sec->vaddr);
            mipsdisasm_pass2(fasm, state, sec->start);
            break;
         case TYPE_SM64_LEVEL:
            // relocate level scripts to .mio0 area
            // TODO: these shouldn't need to be relocated if load offset can be computed
            fprintf(fasm, ".space 0x%05x, 0x01 # %s\n", sec->end - sec->start, sec->label);
            break;
         case TYPE_SM64_BEHAVIOR:
            // behaviors are done below
            fprintf(fasm, ".space 0x%05x, 0x01 # %s\n", sec->end - sec->start, sec->label);
            break;
         case TYPE_M64:
            parse_music_sequences(fasm, data, sec, args, &makeheader_music);
            break;
         case TYPE_SFX_CTL:
            if (sfxSec == NULL)
               sfxSec = sec;
            else
               parse_sound_banks(fasm, data, sec, sfxSec, args, &makeheader_music); //Fix header later
            break;
         case TYPE_SFX_TBL:
            if (sfxSec == NULL)
               sfxSec = sec;
            else
               parse_sound_banks(fasm, data, sfxSec, sec, args, &makeheader_music); //Fix header later
            break;
         case TYPE_INSTRUMENT_SET:
            parse_instrument_set(fasm, data, sec);
            break;
         default:
            ERROR("Don't know what to do with type %d\n", sec->type);
            exit(1);
            break;
      }
      prev_end = sec->end;
   }

   strbuf_alloc(&makeheader_mio0, 1024);
   strbuf_sprintf(&makeheader_mio0, "MIO0_FILES =");

   strbuf_alloc(&makeheader_level, 1024);
   strbuf_sprintf(&makeheader_level, "LEVEL_FILES =");

   fmake = fopen(makefile_name, "w");
   fprintf(fmake, "TARGET = %s\n", config->basename);
   fprintf(fmake, "LD_SCRIPT = $(TARGET).ld\n");
   fprintf(fmake, "MIO0_DIR = %s\n", MIO0_SUBDIR);
   fprintf(fmake, "TEXTURE_DIR = %s\n", TEXTURE_SUBDIR);
   fprintf(fmake, "GEO_DIR = %s\n", GEO_SUBDIR);
   fprintf(fmake, "LEVEL_DIR = %s\n\n", LEVEL_SUBDIR);
   fprintf(fmake, "MUSIC_DIR = %s\n\n", MUSIC_SUBDIR);

   fprintf(fasm, "\n.section .mio0\n");
   for (s = 0; s < config->section_count; s++) {
      split_section *sec = &sections[s];
      switch (sec->type) {
         case TYPE_SM64_GEO:
         {
            char geofilename[FILENAME_MAX];
            FILE *fgeo;
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(geofilename, "%s.%06X.geo.s", config->basename, sec->start);
               sprintf(start_label, "L%06X", sec->start);
            } else {
               sprintf(geofilename, "%s.geo.s", sec->label);
               strcpy(start_label, sec->label);
            }
            sprintf(outfilename, "%s/%s", GEO_SUBDIR, geofilename);
            sprintf(outfilepath, "%s/%s", args->output_dir, outfilename);

            // decode and write level data out
            fgeo = fopen(outfilepath, "w");
            if (fgeo == NULL) {
               perror(outfilepath);
               exit(1);
            }
            write_geolayout(fgeo, &data[sec->start], 0, sec->end - sec->start, state);
            fclose(fgeo);

            fprintf(fasm, "\n.align 4, 0x01\n");
            fprintf(fasm, ".global %s\n", start_label);
            fprintf(fasm, "%s:\n", start_label);
            fprintf(fasm, ".include \"%s\"\n", outfilename);
            fprintf(fasm, "%s_end:\n", start_label);
            // append to Makefile
            strbuf_sprintf(&makeheader_level, " \\\n$(GEO_DIR)/%s", geofilename);
            break;
         }
         case TYPE_BLAST:
         case TYPE_GZIP:
         case TYPE_MIO0:
         {
            char binfilename[FILENAME_MAX];
            char extension[8] = {0};
            unsigned char *lut;
            char binasmfilename[FILENAME_MAX];
            FILE *binasm;
            unsigned char *binfilecontents = NULL;
            long binfilelen = 0;
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(start_label, "L%06X", sec->start);
            } else {
               strcpy(start_label, sec->label);
            }
            sprintf(binfilename, "%s.s", start_label);
            sprintf(binasmfilename, "%s/%s", bin_dir, binfilename);
            // decode and write
            binasm = fopen(binasmfilename, "w");
            if (binasm == NULL) {
               perror(binasmfilename);
               exit(1);
            }
            fprintf(binasm, "# generated by n64split\n.section .rodata\n\n.include \"%s\"\n", MACROS_FILE);
            switch (sec->type) {
               case TYPE_BLAST:
                  INFO("Section Blast: %d %s %X-%X\n", sec->subtype, sec->label, sec->start, sec->end);
                  sprintf(extension, "bc%d", sec->subtype);
                  break;
               case TYPE_MIO0:
                  INFO("Section MIO0: %s %X-%X\n", sec->label, sec->start, sec->end);
                  strcpy(extension, "mio0");
                  break;
               case TYPE_GZIP:
                  INFO("Section GZIP: %s %X-%X\n", sec->label, sec->start, sec->end);
                  strcpy(extension, "gz");
                  break;
               default:
                  break;
            }
            sprintf(outfilename, "%s.%s", start_label, extension);
            sprintf(binfilename, "%s/%s.bin", bin_dir, start_label);
            sprintf(mio0filename, "%s/%s", mio0_dir, outfilename);
            write_file(mio0filename, &data[sec->start], sec->end - sec->start);

            fprintf(fasm, "\n.align 4, 0x01\n");
            fprintf(fasm, ".global %s\n", start_label);
            fprintf(fasm, "%s:\n", start_label);
            fprintf(fasm, ".incbin \"%s/%s\"\n", MIO0_SUBDIR, outfilename);
            fprintf(fasm, "%s_end:\n", start_label);

            // append to Makefile
            strbuf_sprintf(&makeheader_mio0, " \\\n$(MIO0_DIR)/%s", outfilename);

            // TODO: use in-memory decompression?
            // extract compressed data
            switch (sec->type) {
               case TYPE_BLAST:
                  // TODO: make this configurable?
                  switch (sec->subtype) {
                     case 4: lut = &data[0x047480]; break;
                     case 5: lut = &data[0x0998E0]; break; // TODO: fix this
                     default: lut = data; break;
                  }
                  blast_decode_file(mio0filename, sec->subtype, binfilename, lut);
                  break;
               case TYPE_MIO0:
                  mio0_decode_file(mio0filename, 0, binfilename);
                  break;
               case TYPE_GZIP:
                  gzip_decode_file(mio0filename, 0, binfilename);
                  break;
               default:
                  break;
            }
            binfilelen = read_file(binfilename, &binfilecontents);

            // extract texture data
            if (sec->children) {
               unsigned int offset = 0;
	       unsigned int next_offset = 0;
               // TODO: add segment base to config file
	       const unsigned int segment_base = 0x07000000;
               unsigned int seg_address = segment_base + offset;
               fprintf(fmake, "$(MIO0_DIR)/%s.bin:", start_label);
               INFO("Extracting textures from %s\n", start_label);
               for (int t = 0; t < sec->child_count; t++) {
                  split_section *child = &sec->children[t];
                  texture *tex = &child->tex;
                  w = tex->width;
                  h = tex->height;
		  if (next_offset > child->start) {
                     ERROR("Error section overlap region %d (%X > %X)\n", t, next_offset, child->start);
		     exit(1);
		  }
		  if (next_offset != child->start) {
                     unsigned gap_len = child->start - next_offset;
		     INFO("Filling gap before region %d (%d bytes)\n", t, gap_len);
		     fprintf(binasm, "# Unknown region %06X-%06X [%X]\n", next_offset, child->start, gap_len);
		     while (gap_len > 0) {
                        int group_len = MIN(gap_len, 0x10);
			fprintf(binasm, ".byte ");
			fprint_hex_source(binasm, &binfilecontents[next_offset], group_len);
			fprintf(binasm, "\n");
			gap_len -= group_len;
			next_offset += group_len;
		     }
                  }
                  offset = tex->offset;
                  seg_address = segment_base + offset;
		  if (child->end) {
		     next_offset = child->end;
		  } else if (tex->format == TYPE_F3D_LIGHT) {
		     next_offset = child->start + 0x18;
		  } else { // assume texture
		     next_offset = child->start + w * h * tex->depth / 8;
		  }
                  fprintf(binasm, "\n");
                  switch (tex->format) {
                     case TYPE_TEX_IA:
                     {
                        sprintf(outfilename, "%s.%05X.ia%d", start_label, offset, tex->depth);
                        ia *img = raw2ia(&binfilecontents[offset], w, h, tex->depth);
                        if (img) {
                           sprintf(outfilepath, "%s/%s.png", texture_dir, outfilename);
                           ia2png(outfilepath, img, w, h);
                           free(img);
                           fprintf(fmake, " $(TEXTURE_DIR)/%s", outfilename);
                        }
                        if (args->raw_texture && binfilelen > 0) {
                           INFO("Saving raw texture for %s\n", start_label);
                           int len = w*h*tex->depth/8;
                           sprintf(outfilepath, "%s/%s", texture_dir, outfilename);
                           write_file(outfilepath, &binfilecontents[offset], len);
                        }
                        fprintf(binasm, "texture_%08X: # 0x%08X\n", seg_address, seg_address);
                        fprintf(binasm, ".incbin \"%s\"\n", outfilename);
                        break;
                     }
                     case TYPE_TEX_I:
                     {
                        sprintf(outfilename, "%s.%05X.i%d", start_label, offset, tex->depth);
                        ia *img = raw2i(&binfilecontents[offset], w, h, tex->depth);
                        if (img) {
                           sprintf(outfilepath, "%s/%s.png", texture_dir, outfilename);
                           ia2png(outfilepath, img, w, h);
                           free(img);
                           fprintf(fmake, " $(TEXTURE_DIR)/%s", outfilename);
                        }
                        if (args->raw_texture && binfilelen > 0) {
                           INFO("Saving raw texture for %s\n", start_label);
                           int len = w*h*tex->depth/8;
                           sprintf(outfilepath, "%s/%s", texture_dir, outfilename);
                           write_file(outfilepath, &binfilecontents[offset], len);
                        }
                        fprintf(binasm, "texture_%08X: # 0x%08X\n", seg_address, seg_address);
                        fprintf(binasm, ".incbin \"%s\"\n", outfilename);
                        break;
                     }
                     case TYPE_TEX_RGBA:
                     {
                        sprintf(outfilename, "%s.%05X.rgba%d", start_label, offset, tex->depth);
                        rgba *img = raw2rgba(&binfilecontents[offset], w, h, tex->depth);
                        if (img) {
                           sprintf(outfilepath, "%s/%s.png", texture_dir, outfilename);
                           rgba2png(outfilepath, img, w, h);
                           free(img);
                           fprintf(fmake, " $(TEXTURE_DIR)/%s", outfilename);
                        }
                        if (args->raw_texture && binfilelen > 0) {
                           INFO("Saving raw texture for %s\n", start_label);
                           int len = w*h*tex->depth/8;
                           sprintf(outfilepath, "%s/%s", texture_dir, outfilename);
                           write_file(outfilepath, &binfilecontents[offset], len);
                        }
                        fprintf(binasm, "texture_%08X: # 0x%08X\n", seg_address, seg_address);
                        fprintf(binasm, ".incbin \"%s\"\n", outfilename);
                        break;
                     }
                     case TYPE_TEX_SKYBOX:
                     {
                        // read in grid of MxN 32x32 tiles and save them as M*31xN*31 image
                        rgba *img;
                        unsigned int sky_offset = offset;
                        int m, n;
                        int tx, ty;
                        m = w/32;
                        n = h/32;
                        img = malloc(w*h*sizeof(rgba));
                        w -= m; // adjust for overlap
                        h -= n;
                        for (ty = 0; ty < n; ty++) {
                           for (tx = 0; tx < m; tx++) {
                              rgba *tile = raw2rgba(&binfilecontents[sky_offset], 32, 32, tex->depth);
                              int cx, cy;
                              for (cy = 0; cy < 31; cy++) {
                                 for (cx = 0; cx < 31; cx++) {
                                    int out_off = 31*w*ty + 31*tx + w*cy + cx;
                                    int in_off = 32*cy+cx;
                                    img[out_off] = tile[in_off];
                                 }
                              }
                              free(tile);
                              sky_offset += 32*32*2;
                           }
                        }
                        sprintf(outfilename, "%s.%05X.skybox.png", start_label, offset);
                        sprintf(outfilepath, "%s/%s", texture_dir, outfilename);
                        rgba2png(outfilepath, img, w, h);
                        free(img);
                        fprintf(fmake, " $(TEXTURE_DIR)/%s", outfilename);
                        break;
                     }
                     case TYPE_F3D_DL:
                     {
                        int sec_len = child->end - child->start;
                        fprintf(binasm, "f3d_%08X: # 0x%08X\n", seg_address, seg_address);
                        for (int o = 0; o < sec_len; o += 8) {
                           unsigned char cmd = binfilecontents[offset + o];
                           unsigned int second = read_u32_be(&binfilecontents[offset + o + 4]);
                           fprintf(binasm, ".word 0x%08X, ", read_u32_be(&binfilecontents[offset + o]));
                           switch (cmd) {
                              case 0x03: // light
                                 fprintf(binasm, "light_%08X\n", second);
                                 break;
                              case 0x04: // vertex
                                 fprintf(binasm, "vertex_%08X\n", second);
                                 break;
                              case 0x06: // f3d
                                 fprintf(binasm, "f3d_%08X\n", second);
                                 break;
                              case 0xFD: // texture
                                 fprintf(binasm, "texture_%08X\n", second);
                                 break;
                              default:
                                 fprintf(binasm, "0x%08X\n", second);
                                 break;
                           }
                        }
                        break;
                     }
                     case TYPE_F3D_LIGHT:
                     {
                        fprintf(binasm, "light_%08X: # 0x%08X\n", seg_address, seg_address);
                        fprintf(binasm, ".byte ");
                        fprint_hex_source(binasm, &binfilecontents[offset], 8);
                        fprintf(binasm, "\n");
                        fprintf(binasm, "light_%08X: # 0x%08X\n", seg_address + 8, seg_address + 8);
                        fprintf(binasm, ".byte ");
                        fprint_hex_source(binasm, &binfilecontents[offset + 8], 8);
                        fprintf(binasm, "\n.byte ");
                        fprint_hex_source(binasm, &binfilecontents[offset + 16], 8);
                        fprintf(binasm, "\n");
                        break;
                     }
                     case TYPE_F3D_VERTEX:
                     {
                        int sec_len = child->end - child->start;
                        fprintf(binasm, "vertex_%08X: # 0x%08X\n", seg_address, seg_address);
                        for (int o = 0; o < sec_len; o += 16) {
                           fprintf(binasm, "vertex ");
                           for (int h = 0; h < 6; h++) {
                              // X, Y, Z, UNUSED, U, V
                              if (h != 3) {
                                 fprintf(binasm, "%6d, ", read_s16_be(&binfilecontents[offset + o + h*2]));
                              }
                           }
                           // R, G, B, A
                           fprint_hex_source(binasm, &binfilecontents[offset + o + 12], 4);
                           fprintf(binasm, "\n");
                        }
                        break;
                     }
                     case TYPE_SM64_COLLISION:
                     {
                        int sec_len = 0;
                        sprintf(outfilename, "%s.%05X.collision", start_label, offset);
                        sprintf(outfilepath, "%s/%s.obj", model_dir, outfilename);
                        INFO("Generating collision model %s\n", outfilename);
                        sec_len = collision2obj(binfilename, offset, outfilepath, start_label, args->model_scale);
                        if (args->raw_texture && binfilelen > 0) {
                           INFO("Saving raw collision for %s\n", start_label);
                           sprintf(outfilepath, "%s/%s", texture_dir, outfilename);
                           write_file(outfilepath, &binfilecontents[offset], sec_len);
                        }
                        fprintf(binasm, "collision_%06X: # 0x%08X\n", seg_address, seg_address);
                        fprintf(binasm, ".incbin \"%s\"\n", outfilename);
                        break;
                     }
                     default:
                        ERROR("Don't know what to do with format %d\n", tex->format);
                        exit(1);
                  }
               }
               fprintf(fmake, "\n\t$(N64GRAPHICS) $@ $^\n\n");
            }

            // extract texture data
            if (args->large_texture) {
               INFO("Generating large texture for %s\n", start_label);
               w = 32;
               h = filesize(binfilename) / (w * (args->large_texture_depth / 8));
               rgba *img = raw2rgba(binfilecontents, w, h, args->large_texture_depth);
               if (img) {
                  sprintf(outfilename, "%s.ALL.png", start_label);
                  sprintf(outfilepath, "%s/%s", texture_dir, outfilename);
                  rgba2png(outfilepath, img, w, h);
                  free(img);
                  fprintf(fmake, " $(TEXTURE_DIR)/%s", outfilename);
                  img = NULL;
               }
            }
            // TODO: write files in correct order to avoid this
            // touch bin, then mio0 files so 'make' doesn't rebuild them right away
            touch_file(binfilename);
            touch_file(mio0filename);
            fclose(binasm);
            break;
         }
         case TYPE_SM64_LEVEL:
         {
            FILE *flevel;
            char levelfilename[FILENAME_MAX];
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(start_label, "L%06X", sec->start);
            } else {
               strcpy(start_label, sec->label);
            }
            INFO("Section relocated level: %s %X-%X\n", start_label, sec->start, sec->end);
            sprintf(levelfilename, "%s.s", start_label);
            sprintf(outfilename, "%s/%s", LEVEL_SUBDIR, levelfilename);
            sprintf(outfilepath, "%s/%s", args->output_dir, outfilename);

            // decode and write level data out
            flevel = fopen(outfilepath, "w");
            if (flevel == NULL) {
               perror(outfilepath);
               exit(1);
            }
            fprintf(flevel, "# level script %s from %X-%X\n\n", start_label, sec->start, sec->end);
            fprintf(flevel, ".section .mio0\n\n");
            fprintf(flevel, ".global %s\n", start_label);
            fprintf(flevel, ".align 4, 0x01\n");
            fprintf(flevel, "%s:\n", start_label);
            write_level(flevel, data, config, s, state);
            fprintf(flevel, "%s_end:\n", start_label);
            fclose(flevel);

            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(start_label, "L%06X", sec->start);
            } else {
               strcpy(start_label, sec->label);
            }
            fprintf(fasm, "\n.include \"%s\"\n", outfilename);
            // append to Makefile
            strbuf_sprintf(&makeheader_level, " \\\n$(LEVEL_DIR)/%s", levelfilename);
            break;
         }
         case TYPE_SM64_BEHAVIOR:
         {
            FILE *f_beh;
            char beh_filename[FILENAME_MAX];
            INFO("Section relocated behavior: %s %X-%X\n", sec->label, sec->start, sec->end);
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(beh_filename, "%06X.s", sec->start);
            } else {
               sprintf(beh_filename, "%s.s", sec->label);
            }
            sprintf(outfilename, "%s/%s", BEHAVIOR_SUBDIR, beh_filename);
            sprintf(outfilepath, "%s/%s", args->output_dir, outfilename);
            // decode and write level data out
            f_beh = fopen(outfilepath, "w");
            if (f_beh == NULL) {
               perror(outfilepath);
               exit(1);
            }
            write_behavior(f_beh, data, config, s, state);
            fclose(f_beh);

            fprintf(fasm, "\n.section .behavior, \"a\"\n");
            fprintf(fasm, "\n.global %s\n", sec->label);
            fprintf(fasm, ".global %s_end\n", sec->label);
            fprintf(fasm, "%s:\n", sec->label);
            fprintf(fasm, ".include \"%s\"\n", outfilename);
            fprintf(fasm, "%s_end:\n", sec->label);
            fprintf(fasm, "\n\n.section .mio0\n");

            // append to Makefile
            strbuf_sprintf(&makeheader_level, " \\\n%s/%s", BEHAVIOR_SUBDIR, beh_filename);
            break;
         }
         default:
            break;
      }
   }
   fprintf(fmake, "\n\n%s", makeheader_mio0.buf);
   fprintf(fmake, "\n\n%s", makeheader_level.buf);
   fprintf(fmake, "\n\n%s", makeheader_music.buf);

   // cleanup
   strbuf_free(&makeheader_mio0);
   strbuf_free(&makeheader_level);
   strbuf_free(&makeheader_music);
   fclose(fmake);
   fclose(fasm);

   // output top-level makefile
   sprintf(makefile_name, "%s/Makefile", args->output_dir);
   fmake = fopen(makefile_name, "w");
   fprintf(fmake, makefile_data);
   fclose(fmake);

   // output collision model material file
   sprintf(makefile_name, "%s/collision.mtl", model_dir);
   fmake = fopen(makefile_name, "w");
   fprintf(fmake, collision_mtl_data);
   fclose(fmake);

   generate_ld_script(args, config);
   generate_geo_macros(args);
}

static void print_usage(void)
{
   ERROR("Usage: n64split [-c CONFIG] [-k] [-m] [-o OUTPUT_DIR] [-s SCALE] [-t] [-v] [-V] ROM\n"
         "\n"
         "n64split v" N64SPLIT_VERSION ": N64 ROM splitter, resource ripper, disassembler\n"
         "\n"
         "Optional arguments:\n"
         " -c CONFIG     ROM configuration file (default: determine from checksum)\n"
         " -k            keep going as much as possible after error\n"
         " -m            merge related instructions in to pseudoinstructions\n"
         " -o OUTPUT_DIR output directory (default: {CONFIG.basename}.split)\n"
         " -r            output raw texture binaries\n"
         " -s SCALE      amount to scale models by (default: %.1f)\n"
         " -t            generate large texture for MIO0 blocks\n"
         " -v            verbose progress output\n"
         " -V            print version information\n"
         "\n"
         "File arguments:\n"
         " ROM        input ROM file\n",
         default_args.model_scale);
   exit(1);
}

static void print_version(void)
{
   ERROR("n64split v" N64SPLIT_VERSION ", using:\n"
         "  %s\n"
         "  %s\n"
         "  %s\n"
         "  %s\n",
         disasm_get_version(), n64graphics_get_read_version(), n64graphics_get_write_version(), config_get_version());
}

// parse command line arguments
static void parse_arguments(int argc, char *argv[], arg_config *config)
{
   int i;
   int file_count = 0;
   if (argc < 2) {
      print_usage();
      exit(1);
   }
   for (i = 1; i < argc; i++) {
      if (argv[i][0] == '-') {
         switch (argv[i][1]) {
            case 'c':
               if (++i >= argc) {
                  print_usage();
               }
               // Unsecure 
               // strcpy(config->config_file, argv[i]);
               // Secure version below 
               strncpy(config->config_file, argv[i], FILENAME_MAX);
               break;
            case 'k':
               config->keep_going = true;
               break;
            case 'm':
               config->merge_pseudo = true;
               break;
            case 'o':
               if (++i >= argc) {
                  print_usage();
               }
               //Unsecure (buffer overflow)
               // strcpy(config->output_dir, argv[i]);
               //Secure version below without buffer overflow 
               strncpy(config->output_dir, argv[i], FILENAME_MAX);
               break;
            case 'r':
               config->raw_texture = true;
               break;
            case 's':
               if (++i >= argc) {
                  print_usage();
               }
               config->model_scale = strtof(argv[i], NULL);
               break;
            case 't':
               config->large_texture = true;
               break;
            case 'v':
               g_verbosity = 1;
               break;
            case 'V':
               print_version();
               exit(0);
               break;
            default:
               print_usage();
               break;
         }
      } else {
         if (file_count == 0) {
            // strcpy(config->input_file, argv[i]);
            //Secure version without buffer overflow 
            strncpy(config->input_file, argv[i], FILENAME_MAX); 
         } else {
            // too many
            print_usage();
         }
         file_count++;
      }
   }
   if (file_count < 1) {
      print_usage();
   }
}

static int detect_config_file(unsigned int c1, unsigned int c2, rom_config *config)
{
#define CONFIGS_DIR "configs"
   dir_list list;
   int config_ret;
   int ret_val = 0;
   int i;

   dir_list_ext(CONFIGS_DIR, ".yaml", &list);

   for (i = 0; i < list.count; i++) {
      config_ret = config_parse_file(list.files[i], config);
      INFO("Checking config file '%s' (%X, %X)\n", list.files[i], config->checksum1, config->checksum2);
      if (config_ret == 0 && c1 == config->checksum1 && c2 == config->checksum2) {
         ERROR("Using config file: %s\n", list.files[i]);
         ret_val = 1;
         break;
      } else {
         config_free(config);
      }
   }

   dir_list_free(&list);

   return ret_val;
}

int main(int argc, char *argv[])
{
   arg_config args;
   rom_config config;
   disasm_state *state;
   long len;
   unsigned char *data;
   int ret_val;
   unsigned int size;
   float percent;
   int i;
   n64_rom_format rom_type;

   args = default_args;
   parse_arguments(argc, argv, &args);

   len = read_file(args.input_file, &data);

   if (len <= 0) {
      return 2;
   }

   // confirm valid N64 ROM
   rom_type = n64_rom_type(data, len);
   switch (rom_type) {
      case N64_ROM_Z64:
         break; // Z64 is expected format
      case N64_ROM_V64:
         // byte-swapped BADC format, swap to big-endian ABCD format for processing
         INFO("Byte-swapping ROM\n");
         swap_bytes(data, len);
         break;
      case N64_ROM_INVALID:
         ERROR("This does not appear to be a valid N64 ROM\n");
         if (!args.keep_going) {
            exit(1);
         }
         break;
   }

   // if no config file supplied, find the right one
   if (0 == strcmp(args.config_file, "")) {
      ret_val = detect_config_file(read_u32_be(data+0x10), read_u32_be(data+0x14), &config);
      if (!ret_val) {
         ERROR("Error: could not find valid config file for '%s'\n", args.input_file);
         return 1;
      }
   } else {
      ret_val = config_parse_file(args.config_file, &config);
      if (ret_val != 0) {
         return 1;
      }
   }

   if (config_validate(&config, len)) {
      return 3;
   }

   // if no output directory specified, construct one from config file
   if (0 == strcmp(args.output_dir, "")) {
      sprintf(args.output_dir, "%s.split", config.basename);
      printf("Splitting into \"%s\" directory\n", args.output_dir);
   }

   // add config labels to disasm state labels
   state = disasm_state_init(ASM_GAS, 1);
   for (i = 0; i < config.label_count; i++) {
      disasm_label_add(state, config.labels[i].name, config.labels[i].ram_addr);
   }

   // first pass disassembler on each asm section
   INFO("Running first pass disassembler...\n");
   for (i = 0; i < config.section_count; i++) {
      if (config.sections[i].type == TYPE_ASM) {
         unsigned int start = config.sections[i].start;
         unsigned int end = config.sections[i].end;
         unsigned int vaddr = config.sections[i].vaddr;
         if (end <= (unsigned int)len) {
            mipsdisasm_pass1(data, start, end - start, vaddr, state);
         } else {
            ERROR("Trying to disassemble past end of file (%X > %X)\n", end, (unsigned int)len);
            exit(1);
         }
      }
   }

   // split the ROM
   INFO("Splitting ROM...\n");
   split_file(data, len, &args, &config, state);

   // print some stats
   printf("\nROM split statistics:\n");
   size = 0;
   for (i = 0; i < config.section_count; i++) {
      if (config.sections[i].type != TYPE_BIN) {
         size += config.sections[i].end - config.sections[i].start;
      }
   }
   percent = (float)(100 * size) / (float)(len);
   printf("Total decoded section size:  %X/%lX (%.2f%%)\n", size, len, percent);
   size = 0;

   return 0;
}
