#!/usr/bin/env python

from __future__ import print_function
import csv
import sys

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)
    sys.stderr.flush()

# find most recent DMA that matches JAL
def FindLatestDma(dmas, jal):
   jal_mask = jal & 0x0FFFFFFF
   for dma in reversed(dmas):
      if jal_mask >= dma.dest and jal_mask < dma.dest + dma.length:
         return dma
   return None

# DMA class stores information about DMA from ROM to RDRAM
class DMA():
   def __init__(self, source, dest, length):
      self.source = source
      self.dest = dest
      self.length = length
      self.jals = []

# ROM class stores detected ROM information
class ROM():
   def __init__(self, rom_id, regions, description, cksum1, cksum2):
      self.rom_id = rom_id
      self.regions = regions
      self.description = description
      self.cksum1 = cksum1
      self.cksum2 = cksum2

rom = ROM("rom", "", "noname", 0x0, 0x0)
dmas = []
jals = []

# command line input checking
if len(sys.argv) < 2:
   eprint("Usage: dma2config.py <LOG_FILE>")
   sys.exit(1)

# read in log file as CSV and parse rows
eprint("Parsing '{}'...".format(sys.argv[1]))
with open(sys.argv[1], 'rb') as csvfile:
   spamreader = csv.reader(csvfile, delimiter=',')
   for row in spamreader:
      if row[0] == 'ROM':
         rom = ROM(row[1], row[2], row[3], int(row[4], 16), int(row[5], 16))
         eprint("ROM info: {}".format(row))
      elif row[0] == 'DMA':
         source = int(row[1], 16)
         if not any(x.source == source for x in dmas):
            dmas.append(DMA(source, int(row[2], 16), int(row[3], 16)))
      elif row[0] == 'JAL' or row[0] == 'JALR':
         jal = int(row[1], 16)
         jals.append(jal)
         dma = FindLatestDma(dmas, jal)
         if dma is None:
            eprint("Error no DMA for JAL %08X" % jal)
         else:
            dma.jals.append(jal)

# sort arrays
eprint("Sorting arrays...")
dmas.sort(key=lambda x: x.dest)
jals.sort()

# merge consecutive DMA regions
eprint("Merging DMA regions...")
dmas_new = []
for dma in dmas:
   merged = False
   for n in dmas_new:
      if dma.source == n.source + n.length and dma.dest == n.dest + n.length:
         n.length += dma.length
         merged = True
      elif n.source == dma.source + dma.length and n.dest == dma.dest + dma.length:
         n.source = dma.source
         n.length += dma.length
         merged = True
   if not merged:
      dmas_new.append(dma)
dmas = dmas_new

# copy of DMAs, sorted by ROM
dmas_rom = sorted(dmas, key=lambda x: x.source)

# output n64split config file
eprint("Generating config file...")
print("// n64split configuration file")
print("// generated by dma2config")
print("name = \"%s\";" % rom.description)
print("")

print("// checksums from ROM header offsets 0x10 and 0x14")
print("// used for auto configuration detection")
print("checksum1 = 0x%08X;" % rom.cksum1)
print("checksum2 = 0x%08X;" % rom.cksum2)
print("")

print("// base filename used for outputs (please, no spaces)")
print("basename = \"%s\";" % rom.rom_id)
print("")

print("// memory map from KSEG0 RAM addresses to ROM offsets")
print("// these were decoded from DMA accesses")
print("memory =")
print("(")
print("   // start     end         ram-to-rom")
last_dma = None
for dma in dmas:
   if dma.jals:
      start = 0x80000000 + dma.dest
      end = start + dma.length
      ram2rom = start - dma.source
      if last_dma is not None:
         print(", // 0x%06X-0x%06X 0x%06X" % (last_dma.source, last_dma.source + last_dma.length, last_dma.length))
      sys.stdout.write("   (0x%08X, 0x%08X, 0x%08X)" % (start, end, ram2rom))
      last_dma = dma
# last DMA gets no comma
if last_dma is not None:
   print("  // 0x%06X-0x%06X 0x%06X" % (last_dma.source, last_dma.source + last_dma.length, last_dma.length))

print(");")
print("")
print("// ranges to split the ROM into")
print("// types:")
print("//   asm      - MIPS assembly block.  Symbol names are in 'labels' list below")
print("//   behavior - behavior script")
print("//   bin      - raw binary, usually data")
print("//   header   - ROM header block")
print("//   instrset - instrument set")
print("//   level    - level commands")
print("//   m64      - M64 music sequence bank")
print("//   mio0     - MIO0 compressed data block.  may have texture breakdown")
print("//   ptr      - RAM address or ROM offset pointer")
print("//")
print("//   textures types:")
print("//      rgba   - 16-bit RGBA (5-5-5-1)")
print("//      ia     - 16/8/4/1-bit greyscale")
print("//      skybox - grid of 32x32 16-bit RGBA")
print("ranges =")
print("(")
print("   // start,  end,      type,     label")
first = True
for dma in dmas_rom:
   if not first:
      print(",")
   else:
      first = False
   sys.stdout.write("   (0x%06X, 0x%06X, \"%s\")" % (dma.source, dma.source + dma.length, "asm" if dma.jals else "bin" ))
print();
print(");")
print("")

print("// Labels for functions or data memory addresses")
print("// All label addresses are RAM addresses")
print("// Order does not matter")
print("labels =")
print("(")
first = True
for jal in jals:
   if not first:
      print(",")
   else:
      first = False
   sys.stdout.write("   (0x%08X, \"proc_%08X\")" % (jal, jal))
print();
print(");")
print("")
